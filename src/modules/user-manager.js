const { PrismaClient } = require('@prisma/client');
const redis = require('redis');

/**
 * Gerenciador de Usu√°rios
 * Respons√°vel por opera√ß√µes de banco de dados, Redis e utilit√°rios de usu√°rios
 */

class UserManager {
    constructor() {
        this.prisma = new PrismaClient();
        this.redisClient = null;
    }

    /**
     * Inicializa conex√£o com Redis
     */
    async initRedis() {
        try {
            const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
            this.redisClient = redis.createClient({ url: redisUrl });

            this.redisClient.on('error', (err) => console.error('‚ùå Redis Error:', err));

            await this.redisClient.connect();
            console.log('‚úÖ Conectado ao Redis\n');

            return this.redisClient;
        } catch (error) {
            console.warn('‚ö†Ô∏è  Redis n√£o dispon√≠vel, continuando sem cache:', error.message);
            return null;
        }
    }

    /**
     * Busca invites com facial_image do banco de dados
     * Prioriza guests sobre participants para o mesmo inviteId
     */
    async fetchInvitesWithFacialImages() {
        try {
            const eventId = process.env.EVENT_ID;
            if (!eventId) {
                throw new Error('EVENT_ID n√£o est√° definido nas vari√°veis de ambiente');
            }

            // Busca TODOS os participants com facial_image do evento
            const participants = await this.prisma.participant.findMany({
                where: {
                    invite: {
                        some: {
                            event_id: eventId
                        }
                    },
                    facial_image: {
                        not: null
                    }
                },
                include: {
                    invite: {
                        where: {
                            event_id: eventId
                        }
                    }
                }
            });

            // Busca TODOS os guests com facial_image do evento
            const guests = await this.prisma.guest.findMany({
                where: {
                    invite: {
                        some: {
                            event_id: eventId
                        }
                    },
                    facial_image: {
                        not: null
                    }
                },
                include: {
                    invite: {
                        where: {
                            event_id: eventId
                        }
                    }
                }
            });

            console.log(`üìä Busca no banco de dados:`);
            console.log(`   üë• ${participants.length} participants com facial_image`);
            console.log(`   üë§ ${guests.length} guests com facial_image`);
            console.log(`   üéØ Total: ${participants.length + guests.length} registros`);

            // Processa participants e guests em um √∫nico Map
            const usersByPersonId = new Map();    // Deduplica por userId (pessoa f√≠sica)
            let imageUpdates = 0;
            let duplicatedPeople = 0;

            // 1. Processa TODOS os participants
            for (const participant of participants) {
                const personId = `participant_${participant.id}`;
                const inviteId = participant.invite[0]?.id || 'no-invite';

                const user = {
                    inviteId: inviteId,
                    userId: participant.id,
                    personKey: personId,  // Chave √∫nica para deduplica
                    name: participant.name,
                    email: participant.email,
                    document: participant.document,
                    cellphone: participant.cellphone,
                    facialImageUrl: participant.facial_image,
                    type: 'participant',
                    priority: 1
                };

                usersByPersonId.set(personId, user);
            }

            // 2. Processa TODOS os guests
            for (const guest of guests) {
                const personId = `guest_${guest.id}`;
                const inviteId = guest.invite[0]?.id || 'no-invite';

                const user = {
                    inviteId: inviteId,
                    userId: guest.id,
                    personKey: personId,  // Chave √∫nica para deduplica
                    name: guest.name,
                    email: guest.email,
                    document: guest.document,
                    cellphone: guest.cellphone,
                    facialImageUrl: guest.facial_image,
                    type: 'guest',
                    priority: 2
                };

                usersByPersonId.set(personId, user);
            }

            // Converte Map para Array
            const users = Array.from(usersByPersonId.values());

            console.log(`\n   üìä Resumo do Processamento:`);
            console.log(`   üë• ${participants.length} participants adicionados`);
            console.log(`   üë§ ${guests.length} guests adicionados`);
            console.log(`   üéØ Total de PESSOAS √öNICAS: ${users.length}`);
            console.log(`   üìã Regra: TODOS participants + TODOS guests com facial_image\n`);

            return users;
        } catch (error) {
            console.error('‚ùå Erro ao buscar usu√°rios:', error.message);
            throw error;
        }
    }

    /**
     * Separa nome completo em primeiro nome e √∫ltimo sobrenome
     */
    splitName(fullName) {
        if (!fullName || typeof fullName !== 'string') {
            return { firstName: 'Usuario', lastName: 'Sem Nome' };
        }

        const nameParts = fullName.trim().split(/\s+/);

        if (nameParts.length === 1) {
            return { firstName: nameParts[0], lastName: 'Sem Sobrenome' };
        }

        // Pega apenas o primeiro nome e √∫ltimo sobrenome
        const firstName = nameParts[0];
        const lastName = nameParts[nameParts.length - 1]; // √öltimo elemento

        return { firstName, lastName };
    }

    /**
     * Formata nome para envio √† catraca (apenas primeiro nome e √∫ltimo sobrenome)
     */
    formatNameForDevice(fullName) {
        const { firstName, lastName } = this.splitName(fullName);
        const formattedName = `${firstName} ${lastName}`.trim();

        // Limita a 50 caracteres conforme especifica√ß√£o da API
        return formattedName.length > 50
            ? formattedName.substring(0, 50)
            : formattedName;
    }

    /**
     * Salva usu√°rio no Redis e cache JSON
     */
    async saveUser(deviceIp, userId, userData, cacheManager) {
        try {
            let redisSuccess = false;
            let jsonSuccess = false;

            // Salva no Redis (usando inviteId como chave se dispon√≠vel)
            if (this.redisClient) {
                const key = `device:${deviceIp}:users`;
                const value = userData.inviteId ? `${userId}:${userData.inviteId}` : userId;
                await this.redisClient.sAdd(key, value);
                redisSuccess = true;
            }

            // Salva no cache JSON
            if (cacheManager) {
                jsonSuccess = await cacheManager.addUser(deviceIp, userId, userData);
            }

            return {
                success: redisSuccess || jsonSuccess,
                redis: redisSuccess,
                json: jsonSuccess
            };
        } catch (error) {
            console.error(`   ‚ö†Ô∏è  Erro ao salvar usu√°rio: ${error.message}`);
            return { success: false, error: error.message };
        }
    }

    /**
     * Remove usu√°rio do Redis e cache JSON
     */
    async removeUser(deviceIp, userId, cacheManager) {
        try {
            let redisSuccess = false;
            let jsonSuccess = false;

            // Remove do Redis
            if (this.redisClient) {
                const key = `device:${deviceIp}:users`;
                await this.redisClient.sRem(key, userId);
                redisSuccess = true;
            }

            // Remove do cache JSON
            if (cacheManager) {
                jsonSuccess = await cacheManager.removeUser(deviceIp, userId);
            }

            return {
                success: redisSuccess || jsonSuccess,
                redis: redisSuccess,
                json: jsonSuccess
            };
        } catch (error) {
            console.error(`   ‚ö†Ô∏è  Erro ao remover usu√°rio: ${error.message}`);
            return { success: false, error: error.message };
        }
    }

    /**
     * Divide array em lotes de tamanho especificado
     */
    chunkArray(array, chunkSize) {
        const chunks = [];
        for (let i = 0; i < array.length; i += chunkSize) {
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    }

    /**
     * Fecha conex√µes
     */
    async close() {
        try {
            await this.prisma.$disconnect();
            if (this.redisClient) {
                await this.redisClient.quit();
                console.log('‚úÖ Conex√µes fechadas');
            }
        } catch (error) {
            console.error('‚ùå Erro ao fechar conex√µes:', error.message);
        }
    }
}

module.exports = UserManager;
