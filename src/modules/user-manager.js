const { PrismaClient } = require('@prisma/client');
const redis = require('redis');

/**
 * Gerenciador de Usu√°rios
 * Respons√°vel por opera√ß√µes de banco de dados, Redis e utilit√°rios de usu√°rios
 */

class UserManager {
    constructor() {
        this.prisma = new PrismaClient();
        this.redisClient = null;
    }

    /**
     * Inicializa conex√£o com Redis
     */
    async initRedis() {
        try {
            const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
            this.redisClient = redis.createClient({ url: redisUrl });

            this.redisClient.on('error', (err) => console.error('‚ùå Redis Error:', err));

            await this.redisClient.connect();
            console.log('‚úÖ Conectado ao Redis\n');

            return this.redisClient;
        } catch (error) {
            console.warn('‚ö†Ô∏è  Redis n√£o dispon√≠vel, continuando sem cache:', error.message);
            return null;
        }
    }

    /**
     * Busca invites com facial_image do banco de dados
     * Prioriza guests sobre participants para o mesmo inviteId
     */
    async fetchInvitesWithFacialImages() {
        try {
            const eventId = process.env.EVENT_ID;
            if (!eventId) {
                throw new Error('EVENT_ID n√£o est√° definido nas vari√°veis de ambiente');
            }

            // Busca invites do evento com participants e guests
            const invites = await this.prisma.invite.findMany({
                where: {
                    event_id: eventId
                },
                include: {
                    participant: true,
                    guest: true
                }
            });

            console.log(`üìä Encontrados ${invites.length} invites do evento`);

            // Processa cada invite e extrai guest OU participant
            const usersMap = new Map(); // Usar Map para garantir unicidade por inviteId
            let participantsCount = 0;
            let guestsCount = 0;
            let skippedCount = 0;

            for (const invite of invites) {
                // Verifica se j√° processou este invite
                if (usersMap.has(invite.id)) {
                    console.warn(`   ‚ö†Ô∏è  Invite duplicado ignorado: ${invite.id}`);
                    continue;
                }

                let selectedPerson = null;
                let personType = null;

                // Prioridade 1: Guest (se existir)
                if (invite.guest) {
                    selectedPerson = invite.guest;
                    personType = 'guest';
                    guestsCount++;
                }
                // Prioridade 2: Participant (se n√£o tiver guest)
                else if (invite.participant) {
                    selectedPerson = invite.participant;
                    personType = 'participant';
                    participantsCount++;
                }

                // Se n√£o tem nem guest nem participant, pula
                if (!selectedPerson) {
                    skippedCount++;
                    continue;
                }

                // Monta o objeto do usu√°rio
                const user = {
                    inviteId: invite.id,                    // ID do invite (chave principal)
                    userId: selectedPerson.id,              // ID do guest ou participant
                    name: selectedPerson.name,
                    email: selectedPerson.email,
                    document: selectedPerson.document,
                    cellphone: selectedPerson.cellphone,
                    facialImageUrl: selectedPerson.facial_image,
                    type: personType,
                    priority: personType === 'guest' ? 2 : 1
                };

                // S√≥ adiciona se tiver facial_image
                if (user.facialImageUrl) {
                    usersMap.set(invite.id, user);
                } else {
                    skippedCount++;
                }
            }

            // Converte Map para Array
            const users = Array.from(usersMap.values());

            console.log(`   üë• Participantes: ${participantsCount}`);
            console.log(`   üë§ Convidados: ${guestsCount}`);
            console.log(`   ‚è≠Ô∏è  Sem facial_image: ${skippedCount}`);
            console.log(`   üéØ Total de usu√°rios com facial: ${users.length}`);
            console.log(`   üìã Regra: Guest > Participant (1 por invite)\n`);

            return users;
        } catch (error) {
            console.error('‚ùå Erro ao buscar usu√°rios:', error.message);
            throw error;
        }
    }

    /**
     * Separa nome completo em primeiro nome e √∫ltimo sobrenome
     */
    splitName(fullName) {
        if (!fullName || typeof fullName !== 'string') {
            return { firstName: 'Usuario', lastName: 'Sem Nome' };
        }

        const nameParts = fullName.trim().split(/\s+/);

        if (nameParts.length === 1) {
            return { firstName: nameParts[0], lastName: 'Sem Sobrenome' };
        }

        // Pega apenas o primeiro nome e √∫ltimo sobrenome
        const firstName = nameParts[0];
        const lastName = nameParts[nameParts.length - 1]; // √öltimo elemento

        return { firstName, lastName };
    }

    /**
     * Formata nome para envio √† catraca (apenas primeiro nome e √∫ltimo sobrenome)
     */
    formatNameForDevice(fullName) {
        const { firstName, lastName } = this.splitName(fullName);
        const formattedName = `${firstName} ${lastName}`.trim();

        // Limita a 50 caracteres conforme especifica√ß√£o da API
        return formattedName.length > 50
            ? formattedName.substring(0, 50)
            : formattedName;
    }

    /**
     * Salva usu√°rio no Redis e cache JSON
     */
    async saveUser(deviceIp, userId, userData, cacheManager) {
        try {
            let redisSuccess = false;
            let jsonSuccess = false;

            // Salva no Redis (usando inviteId como chave se dispon√≠vel)
            if (this.redisClient) {
                const key = `device:${deviceIp}:users`;
                const value = userData.inviteId ? `${userId}:${userData.inviteId}` : userId;
                await this.redisClient.sAdd(key, value);
                redisSuccess = true;
            }

            // Salva no cache JSON
            if (cacheManager) {
                jsonSuccess = await cacheManager.addUser(deviceIp, userId, userData);
            }

            return {
                success: redisSuccess || jsonSuccess,
                redis: redisSuccess,
                json: jsonSuccess
            };
        } catch (error) {
            console.error(`   ‚ö†Ô∏è  Erro ao salvar usu√°rio: ${error.message}`);
            return { success: false, error: error.message };
        }
    }

    /**
     * Remove usu√°rio do Redis e cache JSON
     */
    async removeUser(deviceIp, userId, cacheManager) {
        try {
            let redisSuccess = false;
            let jsonSuccess = false;

            // Remove do Redis
            if (this.redisClient) {
                const key = `device:${deviceIp}:users`;
                await this.redisClient.sRem(key, userId);
                redisSuccess = true;
            }

            // Remove do cache JSON
            if (cacheManager) {
                jsonSuccess = await cacheManager.removeUser(deviceIp, userId);
            }

            return {
                success: redisSuccess || jsonSuccess,
                redis: redisSuccess,
                json: jsonSuccess
            };
        } catch (error) {
            console.error(`   ‚ö†Ô∏è  Erro ao remover usu√°rio: ${error.message}`);
            return { success: false, error: error.message };
        }
    }

    /**
     * Divide array em lotes de tamanho especificado
     */
    chunkArray(array, chunkSize) {
        const chunks = [];
        for (let i = 0; i < array.length; i += chunkSize) {
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    }

    /**
     * Fecha conex√µes
     */
    async close() {
        try {
            await this.prisma.$disconnect();
            if (this.redisClient) {
                await this.redisClient.quit();
                console.log('‚úÖ Conex√µes fechadas');
            }
        } catch (error) {
            console.error('‚ùå Erro ao fechar conex√µes:', error.message);
        }
    }
}

module.exports = UserManager;
